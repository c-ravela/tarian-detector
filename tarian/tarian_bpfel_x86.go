// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package tarian

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type tarianPerCpuBufferT struct{ Data [131072]uint8 }

type tarianScratchSpaceT struct {
	Data [8192]uint8
	Pos  uint64
}

type tarianTarianStatsT struct {
	N_trgs                      uint64
	N_trgsSent                  uint64
	N_trgsDropped               uint64
	N_trgsDroppedMaxMapCapacity uint64
	N_trgsDroppedMaxBufferSize  uint64
	N_trgsReadError             uint64
	N_trgsUnknown               uint64
}

// loadTarian returns the embedded CollectionSpec for tarian.
func loadTarian() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TarianBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load tarian: %w", err)
	}

	return spec, err
}

// loadTarianObjects loads tarian and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*tarianObjects
//	*tarianPrograms
//	*tarianMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTarianObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTarian()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// tarianSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianSpecs struct {
	tarianProgramSpecs
	tarianMapSpecs
}

// tarianSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianProgramSpecs struct {
	TdfAcceptE   *ebpf.ProgramSpec `ebpf:"tdf_accept_e"`
	TdfAcceptR   *ebpf.ProgramSpec `ebpf:"tdf_accept_r"`
	TdfBindE     *ebpf.ProgramSpec `ebpf:"tdf_bind_e"`
	TdfBindR     *ebpf.ProgramSpec `ebpf:"tdf_bind_r"`
	TdfCloneE    *ebpf.ProgramSpec `ebpf:"tdf_clone_e"`
	TdfCloneR    *ebpf.ProgramSpec `ebpf:"tdf_clone_r"`
	TdfCloseE    *ebpf.ProgramSpec `ebpf:"tdf_close_e"`
	TdfCloseR    *ebpf.ProgramSpec `ebpf:"tdf_close_r"`
	TdfConnectE  *ebpf.ProgramSpec `ebpf:"tdf_connect_e"`
	TdfConnectR  *ebpf.ProgramSpec `ebpf:"tdf_connect_r"`
	TdfExecveE   *ebpf.ProgramSpec `ebpf:"tdf_execve_e"`
	TdfExecveR   *ebpf.ProgramSpec `ebpf:"tdf_execve_r"`
	TdfExecveatE *ebpf.ProgramSpec `ebpf:"tdf_execveat_e"`
	TdfExecveatR *ebpf.ProgramSpec `ebpf:"tdf_execveat_r"`
	TdfListenE   *ebpf.ProgramSpec `ebpf:"tdf_listen_e"`
	TdfListenR   *ebpf.ProgramSpec `ebpf:"tdf_listen_r"`
	TdfOpenE     *ebpf.ProgramSpec `ebpf:"tdf_open_e"`
	TdfOpenR     *ebpf.ProgramSpec `ebpf:"tdf_open_r"`
	TdfOpenat2E  *ebpf.ProgramSpec `ebpf:"tdf_openat2_e"`
	TdfOpenat2R  *ebpf.ProgramSpec `ebpf:"tdf_openat2_r"`
	TdfOpenatE   *ebpf.ProgramSpec `ebpf:"tdf_openat_e"`
	TdfOpenatR   *ebpf.ProgramSpec `ebpf:"tdf_openat_r"`
	TdfReadE     *ebpf.ProgramSpec `ebpf:"tdf_read_e"`
	TdfReadR     *ebpf.ProgramSpec `ebpf:"tdf_read_r"`
	TdfReadvE    *ebpf.ProgramSpec `ebpf:"tdf_readv_e"`
	TdfReadvR    *ebpf.ProgramSpec `ebpf:"tdf_readv_r"`
	TdfSocketE   *ebpf.ProgramSpec `ebpf:"tdf_socket_e"`
	TdfSocketR   *ebpf.ProgramSpec `ebpf:"tdf_socket_r"`
	TdfWriteE    *ebpf.ProgramSpec `ebpf:"tdf_write_e"`
	TdfWriteR    *ebpf.ProgramSpec `ebpf:"tdf_write_r"`
	TdfWritevE   *ebpf.ProgramSpec `ebpf:"tdf_writev_e"`
	TdfWritevR   *ebpf.ProgramSpec `ebpf:"tdf_writev_r"`
}

// tarianMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianMapSpecs struct {
	Events         *ebpf.MapSpec `ebpf:"events"`
	PeaPerCpuArray *ebpf.MapSpec `ebpf:"pea_per_cpu_array"`
	ScratchSpace   *ebpf.MapSpec `ebpf:"scratch_space"`
	TarianStats    *ebpf.MapSpec `ebpf:"tarian_stats"`
}

// tarianObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianObjects struct {
	tarianPrograms
	tarianMaps
}

func (o *tarianObjects) Close() error {
	return _TarianClose(
		&o.tarianPrograms,
		&o.tarianMaps,
	)
}

// tarianMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianMaps struct {
	Events         *ebpf.Map `ebpf:"events"`
	PeaPerCpuArray *ebpf.Map `ebpf:"pea_per_cpu_array"`
	ScratchSpace   *ebpf.Map `ebpf:"scratch_space"`
	TarianStats    *ebpf.Map `ebpf:"tarian_stats"`
}

func (m *tarianMaps) Close() error {
	return _TarianClose(
		m.Events,
		m.PeaPerCpuArray,
		m.ScratchSpace,
		m.TarianStats,
	)
}

// tarianPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianPrograms struct {
	TdfAcceptE   *ebpf.Program `ebpf:"tdf_accept_e"`
	TdfAcceptR   *ebpf.Program `ebpf:"tdf_accept_r"`
	TdfBindE     *ebpf.Program `ebpf:"tdf_bind_e"`
	TdfBindR     *ebpf.Program `ebpf:"tdf_bind_r"`
	TdfCloneE    *ebpf.Program `ebpf:"tdf_clone_e"`
	TdfCloneR    *ebpf.Program `ebpf:"tdf_clone_r"`
	TdfCloseE    *ebpf.Program `ebpf:"tdf_close_e"`
	TdfCloseR    *ebpf.Program `ebpf:"tdf_close_r"`
	TdfConnectE  *ebpf.Program `ebpf:"tdf_connect_e"`
	TdfConnectR  *ebpf.Program `ebpf:"tdf_connect_r"`
	TdfExecveE   *ebpf.Program `ebpf:"tdf_execve_e"`
	TdfExecveR   *ebpf.Program `ebpf:"tdf_execve_r"`
	TdfExecveatE *ebpf.Program `ebpf:"tdf_execveat_e"`
	TdfExecveatR *ebpf.Program `ebpf:"tdf_execveat_r"`
	TdfListenE   *ebpf.Program `ebpf:"tdf_listen_e"`
	TdfListenR   *ebpf.Program `ebpf:"tdf_listen_r"`
	TdfOpenE     *ebpf.Program `ebpf:"tdf_open_e"`
	TdfOpenR     *ebpf.Program `ebpf:"tdf_open_r"`
	TdfOpenat2E  *ebpf.Program `ebpf:"tdf_openat2_e"`
	TdfOpenat2R  *ebpf.Program `ebpf:"tdf_openat2_r"`
	TdfOpenatE   *ebpf.Program `ebpf:"tdf_openat_e"`
	TdfOpenatR   *ebpf.Program `ebpf:"tdf_openat_r"`
	TdfReadE     *ebpf.Program `ebpf:"tdf_read_e"`
	TdfReadR     *ebpf.Program `ebpf:"tdf_read_r"`
	TdfReadvE    *ebpf.Program `ebpf:"tdf_readv_e"`
	TdfReadvR    *ebpf.Program `ebpf:"tdf_readv_r"`
	TdfSocketE   *ebpf.Program `ebpf:"tdf_socket_e"`
	TdfSocketR   *ebpf.Program `ebpf:"tdf_socket_r"`
	TdfWriteE    *ebpf.Program `ebpf:"tdf_write_e"`
	TdfWriteR    *ebpf.Program `ebpf:"tdf_write_r"`
	TdfWritevE   *ebpf.Program `ebpf:"tdf_writev_e"`
	TdfWritevR   *ebpf.Program `ebpf:"tdf_writev_r"`
}

func (p *tarianPrograms) Close() error {
	return _TarianClose(
		p.TdfAcceptE,
		p.TdfAcceptR,
		p.TdfBindE,
		p.TdfBindR,
		p.TdfCloneE,
		p.TdfCloneR,
		p.TdfCloseE,
		p.TdfCloseR,
		p.TdfConnectE,
		p.TdfConnectR,
		p.TdfExecveE,
		p.TdfExecveR,
		p.TdfExecveatE,
		p.TdfExecveatR,
		p.TdfListenE,
		p.TdfListenR,
		p.TdfOpenE,
		p.TdfOpenR,
		p.TdfOpenat2E,
		p.TdfOpenat2R,
		p.TdfOpenatE,
		p.TdfOpenatR,
		p.TdfReadE,
		p.TdfReadR,
		p.TdfReadvE,
		p.TdfReadvR,
		p.TdfSocketE,
		p.TdfSocketR,
		p.TdfWriteE,
		p.TdfWriteR,
		p.TdfWritevE,
		p.TdfWritevR,
	)
}

func _TarianClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed tarian_bpfel_x86.o
var _TarianBytes []byte
