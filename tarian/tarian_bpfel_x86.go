// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package tarian

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type tarianEventDataT struct {
	Context struct {
		Ts   uint64
		Task struct {
			StartTime     uint64
			HostPid       uint32
			HostTgid      uint32
			HostPpid      uint32
			Pid           uint32
			Tgid          uint32
			Ppid          uint32
			Uid           uint32
			Gid           uint32
			CgroupId      uint64
			MountNsId     uint64
			PidNsId       uint64
			ExecId        uint64
			ParentExecId  uint64
			EexecId       uint64
			EparentExecId uint64
			Comm          [16]uint8
			Cwd           [4096]uint8
		}
		EventId     uint32
		Syscall     int32
		ProcessorId uint16
	}
	Buf struct {
		NumFields  uint8
		FieldTypes uint64
		Data       [10240]uint8
	}
	SystemInfo struct {
		Sysname    [65]uint8
		Nodename   [65]uint8
		Release    [65]uint8
		Version    [65]uint8
		Machine    [65]uint8
		Domainname [65]uint8
	}
}

// loadTarian returns the embedded CollectionSpec for tarian.
func loadTarian() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TarianBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load tarian: %w", err)
	}

	return spec, err
}

// loadTarianObjects loads tarian and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*tarianObjects
//	*tarianPrograms
//	*tarianMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTarianObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTarian()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// tarianSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianSpecs struct {
	tarianProgramSpecs
	tarianMapSpecs
}

// tarianSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianProgramSpecs struct {
	KprobeAccept      *ebpf.ProgramSpec `ebpf:"kprobe_accept"`
	KprobeBind        *ebpf.ProgramSpec `ebpf:"kprobe_bind"`
	KprobeClone       *ebpf.ProgramSpec `ebpf:"kprobe_clone"`
	KprobeClose       *ebpf.ProgramSpec `ebpf:"kprobe_close"`
	KprobeConnect     *ebpf.ProgramSpec `ebpf:"kprobe_connect"`
	KprobeExecve      *ebpf.ProgramSpec `ebpf:"kprobe_execve"`
	KprobeExecveat    *ebpf.ProgramSpec `ebpf:"kprobe_execveat"`
	KprobeListen      *ebpf.ProgramSpec `ebpf:"kprobe_listen"`
	KprobeOpen        *ebpf.ProgramSpec `ebpf:"kprobe_open"`
	KprobeOpenat      *ebpf.ProgramSpec `ebpf:"kprobe_openat"`
	KprobeOpenat2     *ebpf.ProgramSpec `ebpf:"kprobe_openat2"`
	KprobeRead        *ebpf.ProgramSpec `ebpf:"kprobe_read"`
	KprobeReadv       *ebpf.ProgramSpec `ebpf:"kprobe_readv"`
	KprobeSocket      *ebpf.ProgramSpec `ebpf:"kprobe_socket"`
	KprobeWrite       *ebpf.ProgramSpec `ebpf:"kprobe_write"`
	KprobeWritev      *ebpf.ProgramSpec `ebpf:"kprobe_writev"`
	KretprobeAccept   *ebpf.ProgramSpec `ebpf:"kretprobe_accept"`
	KretprobeBind     *ebpf.ProgramSpec `ebpf:"kretprobe_bind"`
	KretprobeClone    *ebpf.ProgramSpec `ebpf:"kretprobe_clone"`
	KretprobeClose    *ebpf.ProgramSpec `ebpf:"kretprobe_close"`
	KretprobeConnect  *ebpf.ProgramSpec `ebpf:"kretprobe_connect"`
	KretprobeExecve   *ebpf.ProgramSpec `ebpf:"kretprobe_execve"`
	KretprobeExecveat *ebpf.ProgramSpec `ebpf:"kretprobe_execveat"`
	KretprobeListen   *ebpf.ProgramSpec `ebpf:"kretprobe_listen"`
	KretprobeOpen     *ebpf.ProgramSpec `ebpf:"kretprobe_open"`
	KretprobeOpenat   *ebpf.ProgramSpec `ebpf:"kretprobe_openat"`
	KretprobeOpenat2  *ebpf.ProgramSpec `ebpf:"kretprobe_openat2"`
	KretprobeRead     *ebpf.ProgramSpec `ebpf:"kretprobe_read"`
	KretprobeReadv    *ebpf.ProgramSpec `ebpf:"kretprobe_readv"`
	KretprobeSocket   *ebpf.ProgramSpec `ebpf:"kretprobe_socket"`
	KretprobeWrite    *ebpf.ProgramSpec `ebpf:"kretprobe_write"`
	KretprobeWritev   *ebpf.ProgramSpec `ebpf:"kretprobe_writev"`
}

// tarianMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tarianMapSpecs struct {
	ErbCpu0        *ebpf.MapSpec `ebpf:"erb_cpu0"`
	ErbCpu1        *ebpf.MapSpec `ebpf:"erb_cpu1"`
	ErbCpu10       *ebpf.MapSpec `ebpf:"erb_cpu10"`
	ErbCpu11       *ebpf.MapSpec `ebpf:"erb_cpu11"`
	ErbCpu12       *ebpf.MapSpec `ebpf:"erb_cpu12"`
	ErbCpu13       *ebpf.MapSpec `ebpf:"erb_cpu13"`
	ErbCpu14       *ebpf.MapSpec `ebpf:"erb_cpu14"`
	ErbCpu15       *ebpf.MapSpec `ebpf:"erb_cpu15"`
	ErbCpu2        *ebpf.MapSpec `ebpf:"erb_cpu2"`
	ErbCpu3        *ebpf.MapSpec `ebpf:"erb_cpu3"`
	ErbCpu4        *ebpf.MapSpec `ebpf:"erb_cpu4"`
	ErbCpu5        *ebpf.MapSpec `ebpf:"erb_cpu5"`
	ErbCpu6        *ebpf.MapSpec `ebpf:"erb_cpu6"`
	ErbCpu7        *ebpf.MapSpec `ebpf:"erb_cpu7"`
	ErbCpu8        *ebpf.MapSpec `ebpf:"erb_cpu8"`
	ErbCpu9        *ebpf.MapSpec `ebpf:"erb_cpu9"`
	Events         *ebpf.MapSpec `ebpf:"events"`
	PeaPerCpuArray *ebpf.MapSpec `ebpf:"pea_per_cpu_array"`
}

// tarianObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianObjects struct {
	tarianPrograms
	tarianMaps
}

func (o *tarianObjects) Close() error {
	return _TarianClose(
		&o.tarianPrograms,
		&o.tarianMaps,
	)
}

// tarianMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianMaps struct {
	ErbCpu0        *ebpf.Map `ebpf:"erb_cpu0"`
	ErbCpu1        *ebpf.Map `ebpf:"erb_cpu1"`
	ErbCpu10       *ebpf.Map `ebpf:"erb_cpu10"`
	ErbCpu11       *ebpf.Map `ebpf:"erb_cpu11"`
	ErbCpu12       *ebpf.Map `ebpf:"erb_cpu12"`
	ErbCpu13       *ebpf.Map `ebpf:"erb_cpu13"`
	ErbCpu14       *ebpf.Map `ebpf:"erb_cpu14"`
	ErbCpu15       *ebpf.Map `ebpf:"erb_cpu15"`
	ErbCpu2        *ebpf.Map `ebpf:"erb_cpu2"`
	ErbCpu3        *ebpf.Map `ebpf:"erb_cpu3"`
	ErbCpu4        *ebpf.Map `ebpf:"erb_cpu4"`
	ErbCpu5        *ebpf.Map `ebpf:"erb_cpu5"`
	ErbCpu6        *ebpf.Map `ebpf:"erb_cpu6"`
	ErbCpu7        *ebpf.Map `ebpf:"erb_cpu7"`
	ErbCpu8        *ebpf.Map `ebpf:"erb_cpu8"`
	ErbCpu9        *ebpf.Map `ebpf:"erb_cpu9"`
	Events         *ebpf.Map `ebpf:"events"`
	PeaPerCpuArray *ebpf.Map `ebpf:"pea_per_cpu_array"`
}

func (m *tarianMaps) Close() error {
	return _TarianClose(
		m.ErbCpu0,
		m.ErbCpu1,
		m.ErbCpu10,
		m.ErbCpu11,
		m.ErbCpu12,
		m.ErbCpu13,
		m.ErbCpu14,
		m.ErbCpu15,
		m.ErbCpu2,
		m.ErbCpu3,
		m.ErbCpu4,
		m.ErbCpu5,
		m.ErbCpu6,
		m.ErbCpu7,
		m.ErbCpu8,
		m.ErbCpu9,
		m.Events,
		m.PeaPerCpuArray,
	)
}

// tarianPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTarianObjects or ebpf.CollectionSpec.LoadAndAssign.
type tarianPrograms struct {
	KprobeAccept      *ebpf.Program `ebpf:"kprobe_accept"`
	KprobeBind        *ebpf.Program `ebpf:"kprobe_bind"`
	KprobeClone       *ebpf.Program `ebpf:"kprobe_clone"`
	KprobeClose       *ebpf.Program `ebpf:"kprobe_close"`
	KprobeConnect     *ebpf.Program `ebpf:"kprobe_connect"`
	KprobeExecve      *ebpf.Program `ebpf:"kprobe_execve"`
	KprobeExecveat    *ebpf.Program `ebpf:"kprobe_execveat"`
	KprobeListen      *ebpf.Program `ebpf:"kprobe_listen"`
	KprobeOpen        *ebpf.Program `ebpf:"kprobe_open"`
	KprobeOpenat      *ebpf.Program `ebpf:"kprobe_openat"`
	KprobeOpenat2     *ebpf.Program `ebpf:"kprobe_openat2"`
	KprobeRead        *ebpf.Program `ebpf:"kprobe_read"`
	KprobeReadv       *ebpf.Program `ebpf:"kprobe_readv"`
	KprobeSocket      *ebpf.Program `ebpf:"kprobe_socket"`
	KprobeWrite       *ebpf.Program `ebpf:"kprobe_write"`
	KprobeWritev      *ebpf.Program `ebpf:"kprobe_writev"`
	KretprobeAccept   *ebpf.Program `ebpf:"kretprobe_accept"`
	KretprobeBind     *ebpf.Program `ebpf:"kretprobe_bind"`
	KretprobeClone    *ebpf.Program `ebpf:"kretprobe_clone"`
	KretprobeClose    *ebpf.Program `ebpf:"kretprobe_close"`
	KretprobeConnect  *ebpf.Program `ebpf:"kretprobe_connect"`
	KretprobeExecve   *ebpf.Program `ebpf:"kretprobe_execve"`
	KretprobeExecveat *ebpf.Program `ebpf:"kretprobe_execveat"`
	KretprobeListen   *ebpf.Program `ebpf:"kretprobe_listen"`
	KretprobeOpen     *ebpf.Program `ebpf:"kretprobe_open"`
	KretprobeOpenat   *ebpf.Program `ebpf:"kretprobe_openat"`
	KretprobeOpenat2  *ebpf.Program `ebpf:"kretprobe_openat2"`
	KretprobeRead     *ebpf.Program `ebpf:"kretprobe_read"`
	KretprobeReadv    *ebpf.Program `ebpf:"kretprobe_readv"`
	KretprobeSocket   *ebpf.Program `ebpf:"kretprobe_socket"`
	KretprobeWrite    *ebpf.Program `ebpf:"kretprobe_write"`
	KretprobeWritev   *ebpf.Program `ebpf:"kretprobe_writev"`
}

func (p *tarianPrograms) Close() error {
	return _TarianClose(
		p.KprobeAccept,
		p.KprobeBind,
		p.KprobeClone,
		p.KprobeClose,
		p.KprobeConnect,
		p.KprobeExecve,
		p.KprobeExecveat,
		p.KprobeListen,
		p.KprobeOpen,
		p.KprobeOpenat,
		p.KprobeOpenat2,
		p.KprobeRead,
		p.KprobeReadv,
		p.KprobeSocket,
		p.KprobeWrite,
		p.KprobeWritev,
		p.KretprobeAccept,
		p.KretprobeBind,
		p.KretprobeClone,
		p.KretprobeClose,
		p.KretprobeConnect,
		p.KretprobeExecve,
		p.KretprobeExecveat,
		p.KretprobeListen,
		p.KretprobeOpen,
		p.KretprobeOpenat,
		p.KretprobeOpenat2,
		p.KretprobeRead,
		p.KretprobeReadv,
		p.KretprobeSocket,
		p.KretprobeWrite,
		p.KretprobeWritev,
	)
}

func _TarianClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed tarian_bpfel_x86.o
var _TarianBytes []byte
